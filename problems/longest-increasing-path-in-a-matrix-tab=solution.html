<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="Given an integer matrix, find the length of the longest increasing path.

From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).

Example 1:

nums = [
  [9,9,4],
  [6,6,8],
  [2,1,1]
]



Return 4

The longest increasing path is [1, 2, 6, 9].

Example 2:

nums = [
  [3,4,5],
  [3,2,6],
  [2,2,1]
]



Return 4

The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases.">
  <meta name="keywords"
        content="Longest Increasing Path in a Matrix, LC 329, leetcode 329, leaked interview questions, hackerank free, bittiger free"/>



  <meta name="author" content="">
  <link rel="icon" href="../favicon.ico">

  <title>LeetFree - Leaked Interview questions from Google Facebook Amazon Microsoft LinkedIn</title>

  <!-- Bootstrap core CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">

  <link href="https://use.fontawesome.com/releases/v5.0.1/css/all.css" rel="stylesheet">

  <!-- <link href="/css/fontawesome-all.min.css" rel="stylesheet"> -->
  <!-- <link href="/css/open-iconic-bootstrap.min.css" rel="stylesheet"> -->

  <!-- DataTable -->
  <!-- <link href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta/css/bootstrap.css" rel="stylesheet">
  <link href="https://cdn.datatables.net/1.10.16/css/dataTables.bootstrap4.min.css" rel="stylesheet"> -->

  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/css/select2.min.css" rel="stylesheet"/>
  <!--<link href="/css/codemirror.css" rel="stylesheet">-->

  <style type="text/css">.CodeMirror {
      border: 1px solid gray;
      height: 100%;
    }
  </style>



  <!-- Custom styles for this template -->
  <link href="../maincss.css" rel="stylesheet">


  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111377072-1"></script>
  <script>
      window.dataLayer = window.dataLayer || [];

      function gtag() {
          dataLayer.push(arguments);
      }

      gtag('js', new Date());

      gtag('config', 'UA-111377072-1');
  </script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-8728288618103299",
      enable_page_level_ads: true
    });
  </script>

  <!-- Baidu Analytics -->









</head>

<body>

<div class="blog-masthead">
  <div class="container">
    <nav class="blog-nav">
      <a class="blog-nav-item" href="../index.html">All Questions</a>
      <a class="blog-nav-item" href="../company/google.html">Google</a>
      <a class="blog-nav-item" href="../company/facebook.html">Facebook</a>
      <a class="blog-nav-item" href="../company/microsoft.html">Microsoft</a>
      <a class="blog-nav-item" href="../company/amazon.html">Amazon</a>
      <a class="blog-nav-item" href="../company/uber.html">Uber</a>
      <a class="blog-nav-item" href="../company/linkedin.html">LinkedIn</a>
      <a class="blog-nav-item" href="../company/twitter.html">Twitter</a>
      <a class="blog-nav-item" href="../company/airbnb.html">Airbnb</a>
      <a class="blog-nav-item" href="../company/snapchat.html">Snapchat</a>
    </nav>
  </div>
</div>

<div class="container">
  

  <div class="blog-header">
    <div class="alert alert-info" role="alert">This website contains ALL LeetCode <b>Premium</b> <i
            class="fas fa-unlock-alt"></i> problems for
      <b>FREE!!</b>.<br/>
      All leaked interview problems are collected from Internet.
    </div>

    <h2>329. Longest Increasing Path in a Matrix</h2>
  </div>

  <div class="row">
    <div class="col-md-9 blog-main">
      <div>
        <!-- Nav tabs -->
        <ul class="nav nav-tabs" role="tablist" id="myTabs">
          <li role="presentation" class="active" id="question-li"><a href="#question" aria-controls="question"
                                                                     role="tab"
                                                                     data-toggle="tab">Question</a>
          </li>
          <li role="presentation" id="solution-li"><a href="#solution" aria-controls="solution" role="tab"
                                                      data-toggle="tab"><i class="fas fa-unlock-alt"></i> Solution</a>
          </li>
        </ul>

        <!-- Tab panes -->
        <div class="tab-content">

          <div role="tabpanel" class="tab-pane active" id="question">
            <br/>
            <p>Given an integer matrix, find the length of the longest increasing path.</p>

<p>
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>

<p>
<b>Example 1:</b>
<pre>
nums = [
  [<font color="red">9</font>,9,4],
  [<font color="red">6</font>,6,8],
  [<font color="red">2</font>,<font color="red">1</font>,1]
]
</pre>
</p>

<p>
Return <code>4</code><br/>

The longest increasing path is <code>[1, 2, 6, 9]</code>.</p>

<p>
<b>Example 2:</b>
<pre>
nums = [
  [<font color="red">3</font>,<font color="red">4</font>,<font color="red">5</font>],
  [3,2,<font color="red">6</font>],
  [2,2,1]
]
</pre>
</p>

<p>
Return <code>4</code><br/>

The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p>

<p><b>Credits:</b><br />Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>
          </div>
          <div role="tabpanel" class="tab-pane" id="solution">
            <br/>
            <div class="block-markdown">
<div class="toc">
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#solution">Solution</a><ul>
<li><a href="#approach-1-naive-dfs-time-limit-exceeded">Approach #1 (Naive DFS) [Time Limit Exceeded]</a></li>
<li><a href="#approach-2-dfs-memoization-accepted">Approach #2 (DFS + Memoization) [Accepted]</a></li>
<li><a href="#approach-3-peeling-onion-accepted">Approach #3 (Peeling Onion) [Accepted]</a></li>
</ul>
</li>
<li><a href="#remarks">Remarks</a></li>
</ul>
</div>
<h2 id="summary">Summary</h2>
<p>This article is for advanced readers. It introduces the following ideas:
Depth First Search (DFS), Memoization, Dynamic programming, Topological Sorting. It explains the relation between dynamic programming and topological sorting.</p>
<h2 id="solution">Solution</h2>
<hr/>
<h4 id="approach-1-naive-dfs-time-limit-exceeded">Approach #1 (Naive DFS) [Time Limit Exceeded]</h4>
<p><strong>Intuition</strong></p>
<p>DFS can find the longest increasing path starting from any cell. We can do this for all the cells.</p>
<p><strong>Algorithm</strong></p>
<p>Each cell can be seen as a vertex in a graph <script type="math/tex; mode=display">G</script>. If two adjacent cells have value <script type="math/tex; mode=display">a < b</script>, i.e. increasing then we have a directed edge <script type="math/tex; mode=display">(a, b)</script>. The problem then becomes:</p>
<blockquote>
<p>Search the longest path in the directed graph <script type="math/tex; mode=display">G</script>.</p>
</blockquote>
<p>Naively, we can use DFS or BFS to visit all the cells connected starting from a root. We update the maximum length of the path during search and find the answer when it finished.</p>
<p>Usually, in DFS or BFS, we can employ a set <code>visited</code> to prevent the cells from duplicate visits. We will introduce a better algorithm based on this in the next section.</p>
<iframe frameborder="0" height="515" name="fTW4zmop" src="https://leetcode.com/playground/fTW4zmop/shared" width="100%"></iframe>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <script type="math/tex; mode=display">O(2^{m+n})</script>. The search is repeated for each valid increasing path. In the worst case we can have <script type="math/tex; mode=display">O(2^{m+n})</script> calls. For example:</li>
</ul>
<iframe frameborder="0" height="173" name="dVdd7KB8" src="https://leetcode.com/playground/dVdd7KB8/shared" width="100%"></iframe>
<ul>
<li>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. For each DFS we need <script type="math/tex; mode=display">O(h)</script> space used by the system stack, where <script type="math/tex; mode=display">h</script> is the maximum depth of the recursion. In the worst case, <script type="math/tex; mode=display">O(h) = O(mn)</script>.</li>
</ul>
<hr/>
<h4 id="approach-2-dfs-memoization-accepted">Approach #2 (DFS + Memoization) [Accepted]</h4>
<p><strong>Intuition</strong></p>
<p>Cache the results for the recursion so that any subproblem will be calculated only once.</p>
<p><strong>Algorithm</strong></p>
<p>From previous analysis, we know that there are many duplicate calculations in the naive approach.</p>
<p>One optimization is that we can use a set to prevent the repeat visit in one DFS search. This optimization will reduce the time complexity for each DFS to <script type="math/tex; mode=display">O(mn)</script> and the total algorithm to <script type="math/tex; mode=display">O(m^2n^2)</script>.</p>
<p>Here, we will introduce more powerful optimization, Memoization.</p>
<blockquote>
<p>In computing, memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p>
</blockquote>
<p>In our problem, we recursively call <code>dfs(x, y)</code> for many times. But if we already know all the results for the four adjacent cells, we only need constant time. During our search if the result for a cell is not calculated, we calculate and cache it; otherwise, we get it from the cache directly.</p>
<iframe frameborder="0" height="513" name="k7MmgcpJ" src="https://leetcode.com/playground/k7MmgcpJ/shared" width="100%"></iframe>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. Each vertex/cell will be calculated once and only once, and each edge will be visited once and only once. The total time complexity is then <script type="math/tex; mode=display">O(V+E)</script>. <script type="math/tex; mode=display">V</script> is the total number of vertices and <script type="math/tex; mode=display">E</script> is the total number of edges. In our problem, <script type="math/tex; mode=display">O(V) = O(mn)</script>, <script type="math/tex; mode=display">O(E) = O(4V) = O(mn)</script>.</p>
</li>
<li>
<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. The cache dominates the space complexity.</p>
</li>
</ul>
<hr/>
<h4 id="approach-3-peeling-onion-accepted">Approach #3 (Peeling Onion) [Accepted]</h4>
<p><strong>Intuition</strong></p>
<p>The result of each cell only related to the result of its neighbors. Can we use dynamic programming?</p>
<p><strong>Algorithm</strong></p>
<p>If we define the longest increasing path starting from cell <script type="math/tex; mode=display">(i, j)</script> as a function</p>
<p>
<script type="math/tex; mode=display">
f(i, j)
</script>
</p>
<p>then we have the following transition function</p>
<p>
<script type="math/tex; mode=display">
f(i, j) = max\{f(x, y)| (x, y)~\mathrm{is~a~neighbor~of} (i, j)~\mathrm{and} ~\mathrm{matrix}[x][y] \gt \mathrm{matrix}[i][j]\} + 1
</script>
</p>
<p>This formula is the same as used in the previous approaches. With such transition function, one may think that it is possible to use dynamic programming to deduce all the results without employing DFS!</p>
<p>That is right with one thing missing: we don't have the dependency list.</p>
<p>For dynamic programming to work, if problem B depends on the result of problem A, then we must make sure that problem A is calculated before problem B. Such order is natural and obvious for many problems. For example the famous Fibonacci sequence:</p>
<p>
<script type="math/tex; mode=display">
F(0) = 1, F(1) = 1, F(n) = F(n - 1) + F(n - 2)
</script>
</p>
<p>The subproblem <script type="math/tex; mode=display">F(n)</script> depends on its two predecessors. Therefore, the natural order from 0 to n is the correct order. The dependent is always behind the dependee.</p>
<p>The terminology of such dependency order is "Topological order" or "Topological sorting":</p>
<blockquote>
<p>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge <script type="math/tex; mode=display">(u, v)</script>, vertex <script type="math/tex; mode=display">u</script> comes before <script type="math/tex; mode=display">v</script> in the ordering.</p>
</blockquote>
<p>In our problem, the topological order is not natural. Without the value in the matrix, we couldn't know the dependency relation of any two neighbors A and B. We have to perform the topological sort explicitly  as a preprocess. After that, we can solve the problem dynamically using our transition function following the stored topological order.</p>
<p>There are several ways to perform the topological sorting. Here we employ one of them called "Peeling Onion".</p>
<p>The idea is that in a DAG, we will have some vertex who doesn't depend on others which we call "leaves". We put these leaves in a list (their internal ordering does matter), and then we remove them from the DAG. After the removal, there will be new leaves. We do the same repeatedly as if we are peeling an onion layer by layer. In the end, the list will have a valid topological ordering of our vertices.</p>
<p>In out problem, since we want the longest path in the DAG, which equals to the total number of layers of the "onion". Thus, we can count the number of layers during "peeling" and return the counts in the end without invoking dynamic programming.</p>
<iframe frameborder="0" height="515" name="z5UXQnGD" src="https://leetcode.com/playground/z5UXQnGD/shared" width="100%"></iframe>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>
<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. The the topological sort is <script type="math/tex; mode=display">O(V+E) = O(mn)</script>.
Here, <script type="math/tex; mode=display">V</script> is the total number of vertices and <script type="math/tex; mode=display">E</script> is the total number of edges. In our problem, <script type="math/tex; mode=display">O(V) = O(mn)</script>, <script type="math/tex; mode=display">O(E) = O(4V) = O(mn)</script>.</p>
</li>
<li>
<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. We need to store the out degrees and each level of leaves.</p>
</li>
</ul>
<hr/>
<h2 id="remarks">Remarks</h2>
<ul>
<li>Memoization: for a problem with massive duplicate calls, cache the results.</li>
<li>Dynamic programming requires the subproblem solved in topological order. In many problems, it coincides the natural order. For those who doesn't, one need perform topological sorting first. Therefore, for those problems with complex topology (like this one), search with memorization is usually an easier and better choice.</li>
</ul>
</div>
          </div>
        </div>
      </div>

    </div>

    <aside class="col-md-3  blog-sidebar">
      <div class="row sidebar-module">
        <ul class="list-group">
          <li class="list-group-item"><span>Difficulty:</span><span class="pull-right">
                              
                                <button class="btn btn-xs btn-danger disabled">Hard</button>
                              
          </span></li>
          <li class="list-group-item"><span>Total Accepted:</span><span class="pull-right">45293</span>
          </li>
          <li class="list-group-item"><span>Total Submissions:</span><span
                  class="pull-right">122651</span></li>

          <li class="list-group-item" style="background: #eee;"><span><i
                  class="fas fa-unlock-alt"></i> Frequency:</span>
            <span class="pull-right">
              48%
            </span>
          </li>
        </ul>
        <ul class="list-group">

          <li class="list-group-item">
            <h4><i class="fas fa-unlock-alt"></i> Companies (leaked): </h4>
            
              <a style="margin:2px" class="btn btn-sm btn-success" href="../company/google.html">Google</a>
            
          </li>

        </ul>
      </div>
    </aside>

  </div>

  <div class="row" >
    <div class="col-md-2">
      <select class="js-example-basic-single" name="state" style="width: 100%;" id="language">
        <option value="cpp">C++</option>
        <option value="py2">Python 2</option>
        <option value="py3">Python 3</option>
      </select>
    </div>
    <div class="col-md-2">

    </div>
  </div>

  <div class="row" >
    <div class="col-md-12 blog-main">
      <div>
        
        <textarea id="code_cpp" name="code_cpp">
          
            
        </textarea>
        
        <textarea id="code_py2" name="code_py2">
          
            
        </textarea>
        
        <textarea id="code_py3" name="code_py3">
          
            
        </textarea>
        
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col-md-12 blog-main">
      <a href="#" class="btn btn-primary" id="submit">Submit Solution</a>
    </div>
  </div>



</div>
<!-- /.container -->

<footer class="blog-footer">
  <a href="mailto:leetfree@gmail.com">Email: leetfree@gmail.com</a>
  <p class="pull-right"><a href="#">Back to top</a></p>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="/assets/js/vendor/jquery.min.js"><\/script>')
</script>
<script src="../js/bootstrap.min.js"></script>
<!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
<script src="../assets/js/ie10-viewport-bug-workaround.js"></script>


<!-- DataTable -->
<!-- <script src="https://cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.10.16/js/dataTables.bootstrap4.min.js"></script> -->

<script src="../main.js"></script>





</body>

</html>